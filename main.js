// data structure and algorithms
class Node {
    constructor(value, left=null, right=null) {
        this.value = value
        this.left = left
        this.right = right
    }

    /*
        All of the methods have the same time and space complexity.
        Time complexity is O(n), because we visit every node exactly one time.
        Space complexity is generated by recursive calls that are put on stack and it depends on the tree.
        Optimistically we will have a balanced tree and the space complexity will be O(logn).
        Pessimistically we will have a path and the space complexity will be O(n).
        Generally the space complexity is O(h), where h is height of the tree.
    */

    calcLeaves() {
        if (this.right === null && this.left === null) {
            return 1
        }
        else if (this.right === null) {
            return this.left.calcLeaves()
        }
        else if (this.left === null) {
            return this.right.calcLeaves()
        }
        return this.right.calcLeaves() + this.left.calcLeaves()
    }

    longestPath() {
        if (this.right === null && this.left === null) {
            return 0
        }
        else if (this.right === null) {
            return 1 + this.left.longestPath()
        }
        else if (this.left === null) {
            return 1 + this.right.longestPath()
        }
        return 1 + Math.max(this.right.longestPath(), this.left.longestPath())
    }

    isIdentical(other) {
        let leftTree
        let rightTree

        if (this.left !== null && other.left !== null) {
            leftTree = this.left.isIdentical(other.left)
        }
        else {
            leftTree = (this.left === other.left)
        }

        if (this.right !== null && other.right !== null) {
            rightTree = this.right.isIdentical(other.right)
        }
        else {
            rightTree = (this.right === other.right)
        }

        return (this.value == other.value) && leftTree && rightTree
    }
}

// tests
function testCalcLeaves() {
    console.log("\nTESTING calcLeaves\n")

    // tree from the task
    let tree1 = new Node(5, new Node(3, new Node(2), new Node(5)), new Node(7, new Node(1), new Node(0, new Node(2), new Node(8, null, new Node(5)))))
    console.log(`test 1 - expected: ${5}, actual: ${tree1.calcLeaves()}`)
    if (5 != tree1.calcLeaves()) return false

    // tree with only root
    let tree2 = new Node(0)
    console.log(`test 2 - expected: ${1}, actual: ${tree2.calcLeaves()}`)
    if (1 != tree2.calcLeaves()) return false

    // tree with only left nodes
    let tree3 = new Node(1, new Node(2, new Node(3, new Node(4, new Node(5)))))
    console.log(`test 3 - expected: ${1}, actual: ${tree3.calcLeaves()}`)
    if (1 != tree3.calcLeaves()) return false

    // tree with only right nodes
    let tree4 = new Node(1, null, new Node(2, null, new Node(3, null, new Node(4, null, new Node(5)))))
    console.log(`test 4 - expected: ${1}, actual: ${tree4.calcLeaves()}`)
    if (1 != tree4.calcLeaves()) return false

    // balanced tree
    let tree5 = new Node(1, new Node(2, new Node(4), new Node(5)), new Node(3, new Node(6), new Node(7)))
    console.log(`test 5 - expected: ${4}, actual: ${tree5.calcLeaves()}`)
    if (4 != tree5.calcLeaves()) return false

    return true
}

function testLongestPath() {
    console.log("\nTESTING longestPath\n")

    let tree1 = new Node(5, new Node(3, new Node(2), new Node(5)), new Node(7, new Node(1), new Node(0, new Node(2), new Node(8, null, new Node(5)))))
    console.log(`test 1 - expected: ${4}, actual: ${tree1.longestPath()}`)
    if (4 != tree1.longestPath()) return false

    let tree2 = new Node(0)
    console.log(`test 2 - expected: ${0}, actual: ${tree2.longestPath()}`)
    if (0 != tree2.longestPath()) return false

    let tree3 = new Node(1, new Node(2, new Node(3, new Node(4, new Node(5)))))
    console.log(`test 3 - expected: ${4}, actual: ${tree3.longestPath()}`)
    if (4 != tree3.longestPath()) return false

    let tree4 = new Node(1, null, new Node(2, null, new Node(3, null, new Node(4, null, new Node(5)))))
    console.log(`test 4 - expected: ${4}, actual: ${tree4.longestPath()}`)
    if (4 != tree4.longestPath()) return false

    let tree5 = new Node(1, new Node(2, new Node(4), new Node(5)), new Node(3, new Node(6), new Node(7)))
    console.log(`test 5 - expected: ${2}, actual: ${tree5.longestPath()}`)
    if (2 != tree5.longestPath()) return false

    return true
}

function testIsIdentical() {
    console.log("\nTESTING isIdentical\n")

    let tree1a = new Node(5, new Node(3, new Node(2), new Node(5)), new Node(7, new Node(1), new Node(0, new Node(2), new Node(8, null, new Node(5)))))
    let tree1b = new Node(5, new Node(3, new Node(2), new Node(5)), new Node(7, new Node(1), new Node(0, new Node(2), new Node(8, null, new Node(5)))))
    console.log(`test 1 - expected: ${true}, actual: ${tree1a.isIdentical(tree1b)}`)
    if (!tree1a.isIdentical(tree1b)) return false

    let tree2a = new Node(0)
    let tree2b = new Node(0)
    console.log(`test 2 - expected: ${true}, actual: ${tree2a.isIdentical(tree2b)}`)
    if (!tree2a.isIdentical(tree2b)) return false

    let tree3a = new Node(1, new Node(2, new Node(3, new Node(4, new Node(5)))))
    let tree3b = new Node(1, null, new Node(2, null, new Node(3, null, new Node(4, null, new Node(5)))))
    console.log(`test 3 - expected: ${false}, actual: ${tree3a.isIdentical(tree3b)}`)
    if (tree3a.isIdentical(tree3b)) return false

    let tree4a = new Node(1, new Node(2, new Node(4), new Node(5)), new Node(3, new Node(6), new Node(7)))
    let tree4b = new Node(0)
    console.log(`test 4 - expected: ${false}, actual: ${tree4a.isIdentical(tree4b)}`)
    if (tree4a.isIdentical(tree4b)) return false

    return true
}

function runTest() {
    if (testCalcLeaves() && testLongestPath() && testIsIdentical()) {
        console.log("\nAll test passed üëç")
    }
    else {
        console.log("\nTests failed üëé")
    }
}

runTest()